@page "/file-upload"
@rendermode InteractiveAuto
@inject ILogger<Fileupload> Logger
@using System.IO
@using System.Text.RegularExpressions
@inject IJSRuntime JS

<PageTitle>File Name Modification</PageTitle>

<h1>File Upload</h1>

<p>
<p>Upload up to @maxAllowedFiles of up to @maxFileSize bytes:</p>
<label>
    <InputFile OnChange="@LoadFiles" multiple />
</label>
</p>

@if (loadedFiles.Count > 0)
{
    <select name="operation" id="operations" @bind="selectedOperation">
    @foreach (Operation op in @operationsValue)
        {
            <option value=@op>@getReadableOperation(@op)</option>
        }
    </select>

    @if (RequiresFrom(selectedOperation))
    {
        <p>
    <label>
        From:
        <input type="text" @bind="from" />
    </label>
</p>
    }
    @if (RequiresTo(selectedOperation))
    {
        <p>
    <label>
        To:
        <input type="text" @bind="to" />
    </label>
</p>
    }
    @if (isLoading)
    {
        <p>Uploading...</p>
    }
    else
    {
        <ul>
    @foreach (var file in loadedFiles)
            {
                <li>@(file.TempName ?? file.File.Name)</li>
            }
        </ul>
        <button @onclick="ChangeTempNames">Change file names</button>
        <button @onclick="ResetNames">Reset names</button>
        <button @onclick="DownloadAllFiles">Download All Files</button>
    }

}

<script>
    window.downloadFileFromStream = async (fileName, contentStreamReference) => {
        const arrayBuffer = await contentStreamReference.arrayBuffer();
        const blob = new Blob([arrayBuffer]);
        const url = URL.createObjectURL(blob);
        const anchorElement = document.createElement('a');
        anchorElement.href = url;
        anchorElement.download = fileName ?? '';
        anchorElement.click();
        anchorElement.remove();
        URL.revokeObjectURL(url);
    }
</script>

@code {
    enum Operation
    {
        changeFileExt,
        addPrefix,
        addSuffix,
        addNumbering,
        removeNCharFromStart,
        removeNCharFromEnd,
        removeDoubleSpace,
        removeCharsFromList,
        replaceText,
        transformWithRegex,
        covertToLowercase,
        covertToUppercase,
        appendDateModified,
        appendDateAccessed,
    }
    private List<CustomBrowserFile> loadedFiles = new();
    private long maxFileSize = 1024 * 2000;
    @* private long maxFileSize = 1024 * 15; *@
    private int maxAllowedFiles = 10;
    private bool isLoading;
    private Operation selectedOperation = Operation.changeFileExt;

    private string? from;
    private string? to;

    Operation[] operationsValue = Enum.GetValues<Operation>();

    private void LoadFiles(InputFileChangeEventArgs e)
    {
        isLoading = true;
        loadedFiles.Clear();

        foreach (var file in e.GetMultipleFiles(maxAllowedFiles))
        {
            try
            {
                loadedFiles.Add(new CustomBrowserFile(file));
            }
            catch (Exception ex)
            {
                Logger.LogError("File: {FileName} Error: {Error}",
                file.Name, ex.Message);
            }
        }

        isLoading = false;
    }
    private async Task DownloadFile(CustomBrowserFile file)
    {
        var stream = file.File.OpenReadStream(@maxFileSize);
        var fileName = file.TempName ?? file.File.Name;

        using var streamRef = new DotNetStreamReference(stream: stream);
        await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
    }

    private async Task DownloadAllFiles()
    {
        foreach (var file in loadedFiles)
        {
            await DownloadFile(file);
        }
    }


    private String ChangeFileExt(string input, string replacement)
    {
        Logger.LogInformation("change file ext", input, replacement);
        var pattern = @"(\.[^.]+)$";
        return Regex.Replace(input, pattern, $".{replacement}");
    }

    private bool RequiresFrom(Operation operation)
    {
        switch (operation)
        {
            case Operation.changeFileExt:
            case Operation.addPrefix:
                return false;
            default:
                return false;
        }
    }
    private bool RequiresTo(Operation operation)
    {
        switch (operation)
        {
            case Operation.changeFileExt:
            case Operation.addPrefix:
                return true;
            default:
                return false;
        }
    }
    private string getReadableOperation(Operation operation)
    {
        switch (operation)
        {
            case Operation.changeFileExt:
                return "Change file extension";
            case Operation.addPrefix:
                return "Add prefix";
            default:
                return "Whatever";
        }
    }
    private Func<string, string, string> getOperationFn(Operation operation)
    {
        switch (operation)
        {
            case Operation.changeFileExt:
                return ChangeFileExt;
            case Operation.addPrefix:
                return ChangeFileExt;
            default:
                return (_, _) => "";
        }
    }
    private void updateTo(ChangeEventArgs e)
    {
        Logger.LogInformation("Update to", to);
        to = e?.Value?.ToString();
    }

    private void ChangeTempNames()
    {
        Logger.LogInformation("Changing names");
        Func<string, string, string> fn = getOperationFn(selectedOperation);
        Logger.LogInformation(to);
        foreach (CustomBrowserFile file in loadedFiles)
        {
            string name = file.TempName ?? file.File.Name;
            string newName = fn(name, to ?? "");
            Logger.LogInformation(newName);
            file.TempName = newName;
            Logger.LogInformation(file.TempName);
        }
    }

    private void ResetNames()
    {
        foreach (CustomBrowserFile f in loadedFiles)
        {
            f.TempName = null;
        }
    }
}