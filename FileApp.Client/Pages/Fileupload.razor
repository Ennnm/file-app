@page "/file-upload"
@rendermode InteractiveAuto
@inject ILogger<Fileupload> Logger
@inject IJSRuntime JS
@using System.IO
@using System.Text.RegularExpressions
@using FileApp.Client.Helpers

<PageTitle>File Name Modification</PageTitle>

<h1>File Upload</h1>
<div class="">
    <p>Upload up to @maxAllowedFiles of up to @maxFileSize bytes:</p>
    <div class="form-group mb-3">
        <label for="fileInput" class="input-group-text">
            Choose File(s)
            <InputFile id="fileInput" OnChange="@LoadFiles" multiple style="display: none;" />
        </label>
    </div>
</div>


@if (loadedFiles.Count > 0)
{

    <div class="input-group mb-3">
    <div class="input-group-prepend">
        <label class="input-group-text" for="operations">Options</label>
    </div>
    <select class="form-control" id="operations" @bind="selectedOperation">
        @foreach (StringHelper.Operation op in @operationsValue)
            {
                <option value=@op>@StringHelper.GetReadableOperation(@op) </option>
            }
        </select>
    </div>
    @if (StringHelper.RequiresFrom(selectedOperation) && StringHelper.RequiresTo(selectedOperation))
    {
        <div class="input-group">
    <div class="input-group-prepend">

        <span class="input-group-text" id="">From and to</span>
    </div>
    <input type="text" class="form-control" @bind:"from" @bind:event="oninput">
    <input type="text" class="form-control" @bind:"to" @bind:event="oninput">
</div>
    }
    else
    {
        @if (StringHelper.RequiresFrom(selectedOperation))
        {
            <div class="input-group mb-3">
    <div class="input-group-prepend">
        <span class="input-group-text" id="inputGroup-sizing-default">From</span>
    </div>
    <input type="text" @bind="from" @bind:event="oninput" class="form-control" aria-label="Default"
        aria-describedby="inputGroup-sizing-default">
</div>

        }
        @if (StringHelper.RequiresTo(selectedOperation))
        {
            <div class="input-group mb-3">
    <div class="input-group-prepend">
        <span class="input-group-text" id="inputGroup-sizing-default">To</span>
    </div>
    <input type="text" @bind="to" @bind:event="oninput" class="form-control" aria-label="Default"
        aria-describedby="inputGroup-sizing-default">
</div>

        }
    }
    @if (isLoading)
    {
        <p>Uploading...</p>
    }
    else
    {
        <ul class="list-group list-group-flush mb-3">
    @foreach (var file in loadedFiles)
            {
                <li class="list-group-item">@(file.TempName ?? file.File.Name)</li>
            }
        </ul>
        @if (@from != null || @to != null)
        {
            <button @onclick="ChangeTempNames" class="btn btn-success">Change file names</button>
        }
        @if (hasBeenChanged)
        {
            <button @onclick="ResetNames" class="btn btn-light">Reset names</button>
            <button @onclick="DownloadAllFiles" class="btn btn-success">Download All Files</button>
        }
    }
}

<script>
    window.downloadFileFromStream = async (fileName, contentStreamReference) => {
        const arrayBuffer = await contentStreamReference.arrayBuffer();
        const blob = new Blob([arrayBuffer]);
        const url = URL.createObjectURL(blob);
        const anchorElement = document.createElement('a');
        anchorElement.href = url;
        anchorElement.download = fileName ?? '';
        anchorElement.click();
        anchorElement.remove();
        URL.revokeObjectURL(url);
    }
</script>

@code {
    private List<CustomBrowserFile> loadedFiles = new();
    private long maxFileSize = 1024 * 2000;
    private int maxAllowedFiles = 10;
    private bool isLoading;
    private StringHelper.Operation selectedOperation = StringHelper.Operation.changeFileExt;

    private string? from;
    private string? to;

    private bool hasBeenChanged = false;
    StringHelper.Operation[] operationsValue = Enum.GetValues<StringHelper.Operation>();

    private void LoadFiles(InputFileChangeEventArgs e)
    {
        isLoading = true;
        loadedFiles.Clear();

        foreach (var file in e.GetMultipleFiles(maxAllowedFiles))
        {
            try
            {
                if (file.Size <= maxFileSize)
                {
                    loadedFiles.Add(new CustomBrowserFile(file));
                }
                // TODO: should throw error if exceeded
            }
            catch (Exception ex)
            {
                Logger.LogError($"File: {file.Name} Error: ", ex.Message);
            }
        }

        isLoading = false;
    }
    private async Task DownloadFile(CustomBrowserFile file)
    {
        var stream = file.File.OpenReadStream(@maxFileSize);
        var fileName = file.TempName ?? file.File.Name;

        using var streamRef = new DotNetStreamReference(stream: stream);
        await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
    }

    private async Task DownloadAllFiles()
    {
        foreach (var file in loadedFiles)
        {
            await DownloadFile(file);
        }
    }

    private void ChangeTempNames()
    {
        hasBeenChanged = true;
        Logger.LogInformation("Changing names");
        var fn = StringHelper.GetOperationFn(selectedOperation);
        for (int i = 0; i < loadedFiles.Count; i++)
        {
            var file = loadedFiles[i];
            string name = file.TempName ?? file.File.Name;
            string newName = fn(name, to ?? "", from ?? "", i);
            file.TempName = newName;
        }
        from = null;
        to = null;
    }

    private void ResetNames()
    {
        hasBeenChanged = false;
        foreach (CustomBrowserFile f in loadedFiles)
        {
            f.TempName = null;
        }
    }
}